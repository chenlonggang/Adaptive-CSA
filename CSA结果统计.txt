files            H(gap)  bzip2.0  Golomb   gamma   MOL   RL1+MOL  RL1   RL2   RL3   RL1+LLRUN  RL5    BIC     (gamma,RL1)  ratio1   ratio2

bible            2.63    1.672    3.208    2.806   2.854  2.750   2.79  3.07  2.92   2.611     2.541  2.321     2.51        0.67     0.49/0.37/0.39
xml.50MB         1.43    0.893    1.481    1.877   1.914  1.287   1.33  1.44  1.37   1.221     1.195  1.132     1.21        0.85     0.63/0.36/0.38
paper1           3.57    2.492    4.667    3.887   4.159  4.233   4.31  4.61  4.41   3.905     3.877  4.200     4.00        0.58     0.42/0.35/0.40
sources.50MB     2.30    1.583    2.796    2.631   2.824  2.516   2.56  2.74  2.60   2.330     2.301  2.261     2.32        0.76     0.52/0.35/0.40
english.50MB     2.71    2.272    3.753    2.921   3.400  3.317   3.23  3.47  3.21   2.964     2.836  2.732     2.74        0.68     0.49/0.36/0.41
 
H(gap):gap序列的香农熵.

RL1:1's Runs*2,2*x-3,映射之后的值用gamma编码编.

RL2:1's Runs*2,2*x-1,映射之后的值用gamma编码编.

RL3:1's Runs*2-1,2*x-2,映射之后的值用gamma编码编.
 
RL4:1's Runs*2-1,2*x-4,映射之后的值用gamma编码编.

BIC: Binary Interpolative Coding/Compression,BIC和其他编码方案混合产生更好效果的余地很小.
     因为BIC已经够好了,好比RL5很难和其他的组合产生好结果一样,因为RL5已经足够好了.


RL5:不映射,按照原始的RL的方法,(值,个数)的形式出现,可能有连续出现的字符中,1的可能性最大:该列结果为最终软件的结果.
     
    故编码规则如下:
      a:如出现连续的1,其游程长位length,则编码位...1,lenght...
      b:如果是非1 gap x,不对其使用RL,编码为...x...
     
    解码规则如下:
      a:若得到1,则紧跟其后的位1的个数.
      b:若得到x!=1,则就是x.
    
   举例:序列:3,2,5,1,1,1,1,2,3,1,1,1,4,2,5,9,1,1,1,7:编码为:
            3,2,5,1,4,2,3,1,3,4,2,5,9,1,3,7,该序列可以使用gamma或其他编码方式编码.
        gamma时:
            011,010,00101,1,00100,010,011,1,011,00100,010,00101,0001001,1,011,00111.
    
GolombX:先RL1,在分段Golomb,参数X表示块大小,
        比如:Golomb2:表示,按照RL1映射之后,每两个数一组,用golomb分组编码.
        
  注释:  k值用4 bits表示,k值没有0,4bits可以表示1~16,当两个数的平均值较大,而当k>16时,固定k=16,
        虽然这一组编码的效率不高,但是这种情况几乎不出现,故总体效果不会变化太多.

gamma: gap序列用gamma编码编码.

LLRUN: 将gamma编码的前缀部分又unary编码换成huffman编码,后街gap的除最高位的bniay coding.先RL1.

(gamma,RL1):将gap序列分段,每段512个gap,每段内选择gamma/RL1的小者,是一种混合编码.该列结果为最终软件的结果.

MOL: 出发点:数据具有局部性,即数据的scale不会频繁变化.
     方法:第一个数gamma编码,之后用1-bit表示scale没有增大,0-bits表示scale增大了.
     比如:2,3,5,4,2,3,1,5的MOL码为:
      010,1,11,0,101,1,100,1,010,1,11,1,01,00,101:共29bits

RL5+byte:RL5之后,结合字节对其编码.

ratio1:1's ratio(gap)

ratio2:1's ratio(S:gamma/RL1/gamma+RL)

